<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Allocator Builder: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Allocator Builder
   </div>
   <div id="projectbrief">Policy Based C++ Template Allocator Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Allocator Builder Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A highly composable, policy based C++ allocator.</p>
<p>The layout idea of the library is was presented by <a href="http://erdani.com/">Andrei Alexandrescu</a> at the <a href="http://cppandbeyond.com/">C++ and Beyond 2013</a> seminar and at the <a href="http://cppcon2015.sched.org/event/95b6c3282248b7e2595c5c3182d7652b">CppCon 2015</a>.</p>
<p>The background behind the idea is to compensate the main problem of malloc and the other current standard allocators, separation of memory pointer and the allocated size. This makes it very difficult for all kind of memory management to handle in a fast way memory allocations and especially deallocations, because the memory manager must find the corresponding length of the pointer that shall be free. Additionally all users of manually raw allocated memory have to store the size anyway to ensure that no access beyond the length of the allocated buffer takes place.</p>
<p>A second idea behind this allocator library is, that one can compose for every use case a special designed one. Example use cases:</p>
<ul>
<li>Collect statistic information about the memory usage profile.</li>
<li>Apply guards to memory allocated blocks to detect buffer under- or overflows, even in release mode of the compiled application.</li>
<li>Wait free allocations in a single threaded environment</li>
</ul>
<p>So the approach is, every allocator returns such a block: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>block {</div>
<div class="line">  <span class="keywordtype">void</span>  *ptr;</div>
<div class="line">  <span class="keywordtype">size_t</span> length;</div>
<div class="line">};</div>
</div><!-- fragment --><p>And a request goes this way: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> myMemBlock = allocator.allocate(42);</div>
</div><!-- fragment --><h2>Motivation </h2>
<p>Raw memory is temporary needed inside a method. Most of the time the amount memory would fit on the stack and so :alloca() is ones friend. But in seldom cases more is needed and so :malloc() must be used. (Allocation on the stack is much faster because it is a wait-free operation and in many cases the allocated memory is much more cache friendly.)</p>
<p>So the code could look like this </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> STACK_THRESHOLD = 1024;</div>
<div class="line"><span class="keywordtype">int</span> neededBytes = 42</div>
<div class="line"><span class="keywordtype">bool</span> wouldFitOnTheStack = neededBytes &lt; STACK_THRESHOLD;</div>
<div class="line"><span class="keywordtype">char</span>* p = wouldFitOnStack? : (<span class="keywordtype">char</span>*):alloca(neededBytes) : <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line">std::unique_ptr&lt;char[]&gt; heapAllocated(!wouldFitOnStack? <span class="keyword">new</span> <span class="keywordtype">char</span>[neededBytes] : <span class="keyword">nullptr</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (!p) {</div>
<div class="line">  p = heapAllocated.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... work with p[0..neededBytes-1]</span></div>
</div><!-- fragment --><p>Everybody would agree that this is not nice! So what if one could encapsulate this into something like: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> STACK_THRESHOLD = 1024;</div>
<div class="line"><span class="keywordtype">int</span> neededBytes = 42</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> fallback_allocator&lt;stack_allocator&lt;STACK_THRESHOLD&gt;, mallocator&gt; LocalAllocator; </div>
<div class="line">LocalAllocator localAllocator;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> block = localAllocator.allocate(neededBytes);</div>
<div class="line"><span class="keyword">auto</span> p = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(block.ptr);</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... work with p[0..neededBytes-1]</span></div>
<div class="line"></div>
<div class="line">localAllocator.deallocate(block); <span class="comment">// better to be deleted by a scope finalizer</span></div>
</div><!-- fragment --><p> So, isn't this much cleaner?</p>
<p>A more advanced allocator with different sized buckets as one are used in <a href="http://www.canonware.com/jemalloc/">jemalloc</a> would look like: </p>
<div class="fragment"><div class="line"><span class="comment">// This defines a FreeList that is later configured by the bucketizer to its size</span></div>
<div class="line"><span class="keyword">typedef</span> freelist&lt;mallocator, DynamicSetSize, DynamicSetSize&gt; FList;</div>
<div class="line"></div>
<div class="line"><span class="comment">// All allocation requests up to 3584 bytes are handled by the cascade of FLists.</span></div>
<div class="line"><span class="comment">// Sizes from 3584 till 4MB are handled by the Heap and all beyond that are forwarded</span></div>
<div class="line"><span class="comment">// directly to the normal OS</span></div>
<div class="line"><span class="keyword">typedef</span> segregator&lt;</div>
<div class="line">  8, freelist&lt;mallocator, 0, 8&gt;, segregator&lt;</div>
<div class="line">    128, bucketizer&lt;FList, 1, 128, 16&gt;, segregator&lt;</div>
<div class="line">      256, bucketizer&lt;FList, 129, 256, 32&gt;, Segegator&lt;</div>
<div class="line">        512, bucketizer&lt;FList, 257, 512, 64&gt;, Segegator&lt;</div>
<div class="line">          1024, bucketizer&lt;FList, 513, 1024, 128&gt;, Segegator&lt;</div>
<div class="line">            2048, bucketizer&lt;FList, 1025, 2048, 256&gt;, Segegator&lt;</div>
<div class="line">              3584, bucketizer&lt;FList, 2049, 3584, 512&gt;, Segegator&lt;</div>
<div class="line">                4072 * 1024, cascading_allocator&lt;Heap&lt;mallocator, 1018, 4096&gt;&gt;, mallocator</div>
<div class="line">              &gt;</div>
<div class="line">            &gt;</div>
<div class="line">          &gt;</div>
<div class="line">        &gt;</div>
<div class="line">      &gt;</div>
<div class="line">    &gt;</div>
<div class="line">  &gt;&gt;AdvancedAllocator;</div>
</div><!-- fragment --><h2>Allocator Overview </h2>
<table class="doxtable">
<tr>
<th>Allocator </th><th>Description  </th></tr>
<tr>
<td>affix_allocator </td><td>Allows to automatically pre- and sufix allocated regions. </td></tr>
<tr>
<td>allocator_with_stats </td><td>An allocator that collects a configured number of statistic information, like number of allocated bytes, number of successful expansions and high tide </td></tr>
<tr>
<td>bucketizer </td><td>Manages a bunch of Allocators with increasing bucket size </td></tr>
<tr>
<td>fallback_allocator </td><td>Either the default Allocator can handle a request, otherwise it is passed to a fall-back Allocator </td></tr>
<tr>
<td>(aligned_)mallocator </td><td>Provides and interface to systems ::malloc(), the aligned variant allocates according to a given alignment </td></tr>
<tr>
<td>segregator </td><td>Separates allocation requests depending on a threshold to Allocator A or B </td></tr>
<tr>
<td>(shared_)freelist </td><td>Manages a list of freed memory blocks in a list for faster re-usage. (The Shared variant is thread safe) </td></tr>
<tr>
<td>(shared_)cascading_allocator </td><td>Manages in a thread safe way Allocators and automatically creates a new one when the previous are out of memory. (The Shared variant is thread safe, but it needs further improvements, because it does not frees unused allocators) </td></tr>
<tr>
<td>(shared_)heap </td><td>A heap block based heap. (The Shared variant is thread safe manner with minimal overhead and as far as possible in a lock-free way.) </td></tr>
<tr>
<td>stack_allocator </td><td>Provides a memory access, taken from the stack </td></tr>
</table>
<h2>Documentation </h2>
<p>Online Documentation is available on <a href="http://felixpetriconi.github.io/AllocatorBuilder/index.html">GitHub.io</a> as well.</p>
<p>There is the begin of a tutorial in the <a href="http://felixpetriconi.github.io/AllocatorBuilder/md__t_u_t_o_r_i_a_l.html">tutorial section</a></p>
<h2>Author </h2>
<p>Felix Petriconi (felix at petriconi.net)</p>
<h2>Contributions </h2>
<p>Comments, feedback or contributions are welcome!</p>
<h2>License </h2>
<p>Boost 1.0 License</p>
<h2>Version </h2>
<p>0.9.6</p>
<h2>Prerequisites </h2>
<ul>
<li>C++ 14 (partly, as far as Visual Studio 2015 supports it)</li>
<li>boost 1.59.0 (lockfree, thread, assert, option)</li>
<li>CMake 2.8 or later</li>
<li>GoogleTest 1.7 (Is part of the repository, because it's CMakeFiles.txt needs some patches to compile with Visual Studio)</li>
</ul>
<h2>Platform </h2>
<table class="doxtable">
<tr>
<th>Compiler </th><th>Status  </th></tr>
<tr>
<td>Visual Studio 2015 x64 </td><td>All tests pass </td></tr>
<tr>
<td>Debian x64, Clang 3.4 </td><td>All tests pass </td></tr>
<tr>
<td>Intel XE Inspector x64 </td><td>No detections </td></tr>
<tr>
<td>Clang thread sanitizer </td><td>No detections </td></tr>
</table>
<h2>Installation Win </h2>
<ul>
<li>Have boost installed and the standard libs be build, install into D:</li>
<li>Clone into e.g. D:</li>
<li>Create a build folder, eg D:</li>
<li>Open a command prompt in that alb_build folder</li>
<li>Have CMake in the path</li>
<li>Execute cmake -G "Visual Studio 14 2015 Win64" ..</li>
<li>Open created solution in ..sln</li>
<li>Compile and run all test (if necessary add D: to search path)</li>
</ul>
<h2>ToDo </h2>
<p>See issue list of <a href="https://github.com/FelixPetriconi/AllocatorBuilder/issues?labels=enhancement&amp;page=1&amp;state=open">open enhancements</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Oct 10 2015 14:19:58 for Allocator Builder by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
