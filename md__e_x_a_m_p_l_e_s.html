<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Allocator Builder: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Allocator Builder
   </div>
   <div id="projectbrief">Policy Based C++ Template Allocator Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__e_x_a_m_p_l_e_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Temporary memory inside a function</h1>
<h2>Problem</h2>
<p>Let's say that we need an unknown amount of memory inside a function. There are different ways to handle this:</p>
<ul>
<li>Create a buffer on the stack that is large enough to handle all cases. ** If it is absolute sure that we never need more memory and that there is never the risk of a stack overflow then this is easiest solution and we should go for it. <div class="fragment"><div class="line"><span class="keywordtype">char</span> buffer[1024];</div>
</div><!-- fragment --></li>
<li>We can dynamically allocate it on the stack with ::alloca(). ** If we are not sure about the needed amount of memory this is more dynamic solution than the fixed buffer. Of course this is as fast as a fixed buffer on the stack, but it introduces the risk of a stack overflow. <div class="fragment"><div class="line"><span class="keywordtype">char</span>* buffer = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(::alloca(1024));</div>
</div><!-- fragment --></li>
<li>If would like to avoid by any chance a stack overflow we could go for the heap by using a unique_ptr&lt;&gt; ** The probability of going out of memory is normally much lower than a stack overflow. But it has the disadvantage that in most of the cases it is much slower, because a call to ::malloc() normally implies a lock and other threads cannot allocate or deallocate at the same time. <div class="fragment"><div class="line">unique_ptr&lt;char[]&gt; buffer(<span class="keyword">new</span> <span class="keywordtype">char</span>[1024]);</div>
</div><!-- fragment --></li>
</ul>
<h2>Solution</h2>
<p>The best would be, if we would have a solution that takes the memory if possible from the stack and if not it goes to the heap. One way would be to use a fallback_allocator in the following way: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> StackThreshold = 4096;</div>
<div class="line"><span class="keyword">typedef</span> fallback_allocator&lt;stack_allocator&lt;StackThreshold&gt;, mallocator&gt; LocalAllocator; </div>
<div class="line">LocalAllocator myAllocator;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> mem = myAllocator.allocate(1024);</div>
<div class="line"><span class="keyword">auto</span> buffer = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(mem.ptr);</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">myAllocator.deallocate(mem); <span class="comment">// this should be better put into a scope finalizer like SCOPE_EXIT</span></div>
</div><!-- fragment --><p> Now we get the memory from the stack until 4096 bytes. Just beyond this, a call to ::malloc() would be done. From my point of view this is a cleaner solution. As well it offers the possibility, easily to expand or reallocate the returned block; by design it automatically covers moving data allocated on the stack to the heap, if not enough memory is left on the stack.</p>
<h1>Memory pool for strings</h1>
<h2>Problem</h2>
<p>Many string class designs use today for short strings a so called "small string optimization". That means that the characters of the string a stored in a const buffer member or the class if the string is shorter than 16 bytes e.g. Memory is allocated from the heap if the representing text is longer. Something similar like: (I do not claim that this is best possible implementation :-) ) </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>string {</div>
<div class="line">  <span class="keywordtype">char</span> local_[16];</div>
<div class="line">  unique_ptr&lt;char[]&gt; p_;</div>
<div class="line">  <span class="keywordtype">int</span> length_;</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   string(<span class="keyword">const</span> <span class="keywordtype">char</span>* t) : length_(0) {</div>
<div class="line">     <span class="keywordtype">int</span> len = t? strlen(t) : 0;</div>
<div class="line">     <span class="keywordflow">if</span> (len == 0) </div>
<div class="line">       <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">     <span class="keywordflow">if</span> (len &lt; 16) {</div>
<div class="line">       strcpy(local_, t, len);</div>
<div class="line">     }</div>
<div class="line">     <span class="keywordflow">else</span> {</div>
<div class="line">       length_ = len+1;</div>
<div class="line">       p_.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[length_]);</div>
<div class="line">       strcpy(p_.get(), t, len);</div>
<div class="line">       p_[len] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">     }</div>
<div class="line">   }  </div>
<div class="line">};</div>
</div><!-- fragment --><p> Let's further assume that SIMD CPU instructions are used in further methods to implement comparison, copy etc. These instructions work on modern CPUs (at least on x86) always on 16 bytes chunks. So we would allocate on the heap the memory in 16 bytes aligned chunks, e.g. 32, 48, 64 etc. So it would be good, if the allocator, that we want to use, automatically returns such aligned memory. But that is not all. Further we assume that our application does lot's of string operations. So there would be lot's of allocation and deallocation operations. We already discussed that these operations are quite expensive. So why not keep the not any more used memory blocks in a pool (or free-list) and reuse them soon. So we start with a freelist: </p>
<div class="fragment"><div class="line">freelist&lt;mallocator, 0, 32, 1024&gt; myFreelist;</div>
</div><!-- fragment --><p> This instance allocates all memory from the heap (via the mallocator) and it stores elements up to 32 bytes in the pool. The max pool size is 1024 elements. This allocator would help for strings that would never be bigger than 32 bytes. In normal cases they get bigger, so let's use a bucketizer that can manage several free-lists: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> shared_freelist&lt;mallocator, internal::DynasticDynamicSet, internal::DynasticDynamicSet, 1024&gt; FList;</div>
<div class="line">bucketizer&lt;FList, 17, 512, 16&gt; myBucket;</div>
</div><!-- fragment --><p> So the typedef specifies a free-list that's min- and max size can be changed during runtime. (Normally this values are set during compile time). The bucketizer creates free-lists in increasing 16 bytes steps capacity, [17-32], [33-48], [49-64], ... Each free-list has a maximum capacity of 1024 elements. So now we can handle strings up to the length of 512 bytes. If this strings can get longer, we have to add a segregator: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> shared_freelist&lt;mallocator, internal::DynasticDynamicSet, internal::DynasticDynamicSet, 1024&gt; FList;</div>
<div class="line">segregator&lt;512, bucketizer&lt;FList, 17, 512, 16&gt;, mallocator&gt; myAllocator;</div>
</div><!-- fragment --><p> Now all allocations up to 512 bytes are handled by the bucketizer and all above is taken directly from the heap.</p>
<p>= Replacement of global ::new() and ::delete</p>
<p>= Creating a custom STL compatible allocator </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 6 2014 22:47:08 for Allocator Builder by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
