<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Allocator Builder: TUTORIAL.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Allocator Builder
   </div>
   <div id="projectbrief">Policy Based C++ Template Allocator Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_t_u_t_o_r_i_a_l_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TUTORIAL.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor"># Tutorial</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">## Temporary memory inside a function</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor"></span><span class="preprocessor">### Problem</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor"></span>Let<span class="stringliteral">&#39;s say that we need an unknown amount of memory inside a function. There are different ways to handle this:</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="stringliteral">* Create a buffer on the stack that is large enough to handle all cases.</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="stringliteral">** If it is absolute sure that we never need more memory and that there is never the risk of a stack overflow then this is easiest solution and we should go for it.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="stringliteral">  char buffer[1024];</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="stringliteral">* We can dynamically allocate it on the stack with ::alloca(). </span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="stringliteral">** If we are not sure about the needed amount of memory this is more dynamic solution than the fixed buffer. Of course this is as fast as a fixed buffer on the stack, but it introduces the risk of a stack overflow.</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="stringliteral">  char* buffer = reinterpret_cast&lt;char*&gt;(::alloca(1024));</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="stringliteral">* If would like to avoid by any chance a stack overflow we could go for the heap by using a unique_ptr&lt;&gt;</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="stringliteral">** The probability of going out of memory is normally much lower than a stack overflow. But it has the disadvantage that in most of the cases it is much slower, because a call to ::malloc() normally implies a lock and other threads cannot allocate or deallocate at the same time.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="stringliteral">  unique_ptr&lt;char[]&gt; buffer(new char[1024]);</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="stringliteral">### Solution</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="stringliteral">The best would be, if we would have a solution that takes the memory if possible from the stack and if not it goes to the heap. One way would be to use a fallback_allocator in the following way:</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="stringliteral">  const int StackThreshold = 4096;</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="stringliteral">  typedef fallback_allocator&lt;stack_allocator&lt;StackThreshold&gt;, mallocator&gt; LocalAllocator; </span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="stringliteral">  LocalAllocator myAllocator;</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="stringliteral">  auto mem = myAllocator.allocate(1024);</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="stringliteral">  auto buffer = reinterpret_cast&lt;char*&gt;(mem.ptr);</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="stringliteral">  ...</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="stringliteral">  myAllocator.deallocate(mem); // this should be better put into a scope finalizer like SCOPE_EXIT</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="stringliteral">Now we get the memory from the stack until 4096 bytes. Just beyond this, a call to ::malloc() would be done. From my point of view this is a cleaner solution. As well it offers the possibility, easily to expand or reallocate the returned block; by design it automatically covers moving data allocated on the stack to the heap, if not enough memory is left on the stack.</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="stringliteral">## Memory pool for strings</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="stringliteral">### Problem</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="stringliteral">Many string class designs use today for short strings a so called &quot;small string optimization&quot;. That means that the characters of the string a stored in a const buffer member or the class if the string is shorter than 16 bytes e.g. Memory is allocated from the heap if the representing text is longer. Something similar like: (I do not claim that this is best possible implementation :-) )</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="stringliteral">class string {</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="stringliteral">  char local_[16];</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="stringliteral">  unique_ptr&lt;char[]&gt; p_;</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="stringliteral">  int length_;</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="stringliteral">   string(const char* t) : length_(0) {</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="stringliteral">     int len = t? strlen(t) : 0;</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="stringliteral">     if (len == 0) </span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="stringliteral">       return;</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="stringliteral">     if (len &lt; 16) {</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="stringliteral">       strcpy(local_, t, len);</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="stringliteral">     }</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="stringliteral">     else {</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="stringliteral">       length_ = len+1;</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="stringliteral">       p_.reset(new char[length_]);</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="stringliteral">       strcpy(p_.get(), t, len);</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="stringliteral">       p_[len] = &#39;</span>\0<span class="stringliteral">&#39;;</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="stringliteral">     }</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="stringliteral">   }</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="stringliteral">   ~string() {</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="stringliteral">   }</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="stringliteral">Let&#39;</span>s further assume that SIMD CPU instructions are used in further methods to implement comparison, copy etc. These instructions work on modern CPUs (at least on x86) always on 16 bytes chunks. So we would allocate on the heap the memory in 16 bytes aligned chunks, e.g. 32, 48, 64 etc. So it would be good, <span class="keywordflow">if</span> the allocator, that we want to use, automatically returns such aligned memory. But that is not all. Further we assume that our application does lot<span class="stringliteral">&#39;s of string operations. So there would be lot&#39;</span>s of allocation and deallocation operations. We already discussed that these operations are quite expensive. So why not keep the not any more used memory blocks in a pool (or free-list) and reuse them soon. So we start with a freelist:</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;~~~</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;freelist&lt;mallocator, 0, 32, 1024&gt; myFreelist;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;~~~</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;This instance allocates all memory from the heap (via the mallocator) and it stores elements up to 32 bytes in the pool. The max pool size is 1024 elements. This allocator would help for strings that would never be bigger than 32 bytes. In normal cases they get bigger, so let&#39;s use a bucketizer that can manage several free-lists:</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;~~~</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;typedef shared_freelist&lt;mallocator, internal::DynasticDynamicSet, internal::DynasticDynamicSet, 1024&gt; FList;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;bucketizer&lt;FList, 17, 512, 16&gt; myBucket;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;~~~</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;So the typedef specifies a free-list that&#39;s min- and max size can be changed during runtime. (Normally this values are set during compile time). The bucketizer creates free-lists in increasing 16 bytes steps capacity, [17-32], [33-48], [49-64], ... Each free-list has a maximum capacity of 1024 elements. So now we can handle strings up to the length of 512 bytes. If this strings can get longer, we have to add a segregator:</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;~~~</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;typedef shared_freelist&lt;mallocator, internal::DynasticDynamicSet, internal::DynasticDynamicSet, 1024&gt; FList;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;segregator&lt;512, bucketizer&lt;FList, 17, 512, 16&gt;, mallocator&gt; myAllocator;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;~~~</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;Now all allocations up to 512 bytes are handled by the bucketizer and all above is taken directly from the heap.</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;The code from the <span class="keywordtype">string</span> class would be rewritten to this:</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;~~~</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;namespace {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keyword">using namespace </span>alb;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classalb_1_1shared__freelist.html">shared_freelist&lt;mallocator, internal::DynasticDynamicSet, internal::DynasticDynamicSet, 1024&gt;</a> FList;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <a class="code" href="classalb_1_1segregator.html">segregator&lt;512, bucketizer&lt;FList, 17, 512, 16&gt;</a>, mallocator&gt; myAllocator;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;}</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="keyword">class </span>string {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keywordtype">char</span> local_[16];</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <a class="code" href="structalb_1_1block.html">alb::block</a> chunk_;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="keywordtype">char</span> *data_;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  string(<span class="keyword">const</span> <span class="keywordtype">char</span>* t) : data_(nullptr) {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordtype">int</span> len = t? strlen(t) : 0;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">if</span> (len == 0) </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span> (len &lt; 16) {</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      strcpy(local_, t, len);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    chunk_ = myAllocator.allocate(len + 1);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">if</span> (chunk_) {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      data_ = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(chunk_.ptr);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      strcpy(data_ , t, len);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      data_ [len] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  }</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  ~string() {</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    myAllocator.deallocate(chunk_);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  }</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;};</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;~~~</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="preprocessor">## Replacement of global ::new() and ::delete()</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="preprocessor"></span><span class="preprocessor">### Problem</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="preprocessor"></span>Let<span class="stringliteral">&#39;s assume that we see potential in replacing the standard heap with our own, custom optimized version. In general this is pretty easy. We only have to replace the global new(), new[]() and the corresponding delete operators. A regular implementation might look like:</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">void* operator new(std::size_t sz) {</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral">  auto result = ::malloc(sz);</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral">  if (result) </span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral">    return result;</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral">  throw std::bad_alloc();</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral">void* operator new[](std::size_t sz) {</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral">  auto result = ::malloc(sz);</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral">  if (result) </span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral">    return result;</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral">  throw std::bad_alloc();</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral">void operator delete(void* ptr)</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral">{</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="stringliteral">  if (ptr)</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="stringliteral">    ::free(ptr);</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="stringliteral">void operator delete[](void* ptr)</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral">{</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral">  if (ptr)</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="stringliteral">    ::free(ptr);</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="stringliteral">### Solution</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="stringliteral">Let&#39;</span>s make the assumption that MyAllocator is a combined allocator from the Allocator-Builder (ALB) library that should serve as the basis of the memory allocation.</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;We cannot use this MyAllocator directly, because the ALB relies on the fact that always an alb::<a class="code" href="structalb_1_1block.html">block</a> must be passed to deallocate().</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;~~~</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;struct <a class="code" href="structalb_1_1block.html">block</a> {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <span class="keywordtype">void</span>* ptr;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="keywordtype">size_t</span> length;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;};</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;~~~</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;Beside the pointer to the memory it contains the length. The operator ::delete(<span class="keywordtype">void</span>*) does not get passed the size of the <a class="code" href="structalb_1_1block.html">block</a>. So we have to keep track by ourselves. Probably the easiest way is to encapsulate our MyAllocator within an <a class="code" href="classalb_1_1affix__allocator.html">affix_allocator</a> with a prefix that contains the length of the <a class="code" href="structalb_1_1block.html">block</a>. I choose for the moment the prefix of type uint32_t, because that can cover memory allocations up to 4GB which is fine for now. (When we come to the point, that it might happen, our application needs more than 4GB in a single chunk, then we can change the prefix to uint64_t).</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;~~~</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;typedef <a class="code" href="classalb_1_1affix__allocator.html">affix_allocator</a>&lt;MyAllocator,uint32_t&gt; MyAllocatorPrefixed;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;~~~</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;Let&#39;s make as a next step two convenience function for allocation and releasing the memory:</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;~~~</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;namespace {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  MyAllocatorPrefixed myGlobalAllocator;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="keywordtype">void</span>* operatorNewInternal(std::size_t n) {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">if</span> (n == 0) {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    n = 1;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="keyword">auto</span> result = myGlobalAllocator.<a class="code" href="classalb_1_1affix__allocator.html#a0d8ff4972c9f852b412d0c6746e33b0c">allocate</a>(sz);</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordflow">if</span> (result) </div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keyword">auto</span> p = myGlobalAllocator.outerToPrefix(result);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    *p = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(result.length);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">return</span> result.<a class="code" href="structalb_1_1block.html#aba144d1fa4c47c4cf5987205a6e430f0">ptr</a>;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="keywordflow">throw</span> std::bad_alloc();</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;}</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="keywordtype">void</span> operatorDeleteInternal(<span class="keywordtype">void</span>* ptr) {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="keywordflow">if</span> (ptr) {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <a class="code" href="structalb_1_1block.html">alb::block</a> pseudoBlock(ptr, 1);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keyword">auto</span> p = myGlobalAllocator.outerToPrefix(pseudoBlock);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <a class="code" href="structalb_1_1block.html">alb::block</a> realBlock(ptr, *p);</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    myGlobalAllocator.deallocate(realBlock);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  }  </div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;}</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;~~~</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;The global operators would become:</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;~~~</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;void* <span class="keyword">operator</span> <span class="keyword">new</span>(std::size_t sz) {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="keywordflow">return</span> operatorNewInternal(sz);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;}</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="keywordtype">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::size_t sz) {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="keywordflow">return</span> operatorNewInternal(sz);</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;}</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="keywordtype">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keywordtype">void</span>* ptr)</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;{</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  operatorDeleteInternal(ptr);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;}</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="keywordtype">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keywordtype">void</span>* ptr)</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;{</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  operatorDeleteInternal(ptr);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;}</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;~~~</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;We are almost done. Finally we have to cope the problem of unknown initialization order before main(). So we encapsulate the allocator into a singleton and then we are done. </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;~~~</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;namespace {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  MyAllocatorPrefixed&amp; myGlobalAllocator() {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keyword">static</span> MyAllocatorPrefixed instance;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">return</span> instance;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;}</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;~~~</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;Or even better, we use a ready <span class="keyword">template</span> from the ALB library and change the code of the helper functions to:</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;~~~</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;void* operatorNewInternal(std::size_t n) {</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="keywordflow">if</span> (n == 0) {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  <span class="keyword">auto</span> result = <a class="code" href="classalb_1_1global__allocator.html">alb::global_allocator&lt;MyAllocator&gt;::instance</a>().allocate(n);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="keywordflow">if</span> (result) </div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keyword">auto</span> p = <a class="code" href="classalb_1_1global__allocator.html">alb::global_allocator&lt;MyAllocator&gt;::instance</a>().outerToPrefix(result);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    *p = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(result.length);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keywordflow">return</span> result.ptr;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  }</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="keywordflow">throw</span> std::bad_alloc();</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;}</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="keywordtype">void</span> operatorDeleteInternal(<span class="keywordtype">void</span>* ptr) {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordflow">if</span> (ptr) {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <a class="code" href="structalb_1_1block.html">alb::block</a> pseudoBlock(ptr, 1);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="keyword">auto</span> p = <a class="code" href="classalb_1_1global__allocator.html">alb::global_allocator&lt;MyAllocator&gt;::instance</a>().outerToPrefix(pseudoBlock);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <a class="code" href="structalb_1_1block.html">alb::block</a> realBlock(ptr, *p);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <a class="code" href="classalb_1_1global__allocator.html">alb::global_allocator&lt;MyAllocator&gt;::instance</a>().deallocate(realBlock);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  }  </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;}</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;~~~</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="preprocessor">## Custom STL compatible allocator</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="preprocessor"></span><span class="preprocessor">### Problem</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="preprocessor"></span>Let<span class="stringliteral">&#39;s assume for the moment that we have a STL container under heavy load and with lot&#39;</span>s of size changes or lot<span class="stringliteral">&#39;s of re-balancing in case of a tree base one. (I know, that changing the design in a way, that regularly rebalancing of the tree is avoided totally is even better.) But stick to the idea for the moment.</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="stringliteral">So we have to implement the complete interface as it is described e.g. in Nicolai Josuttis excellent book &quot;The Standard Template Library&quot;. --&gt; Refer to adendum pdf!</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="stringliteral">###Solution</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="stringliteral">Not very much must be done. Just take the generic alb::stl_allocator and we are done:</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="stringliteral">  alb::global_allocator&lt;MyAllocator&gt; globalInstance;</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="stringliteral">  struct MyValues;</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="stringliteral">  typedef alb::stl_allocator&lt;MyValues, alb::global_allocator&lt;MyAllocator&gt;&gt;  MySTLAllocator;</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="stringliteral">Now we can use in in our code as:</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="stringliteral">  std::vector&lt;MyValues, MySTLAllocator&gt; myValueVector;</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="stringliteral">Or when we have to deal with a map:</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="stringliteral">  alb::global_allocator&lt;MyAllocator&gt; globalInstance;</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="stringliteral">  struct MyValues;</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="stringliteral">  typedef std::pair&lt;const int, MyValue&gt; MyMapPair;</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="stringliteral">  typedef alb::stl_allocator&lt;MyMapPair, alb::global_allocator&lt;MyAllocator&gt;&gt;  MyMapAllocator;</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="stringliteral">  std::map&lt;int, MyValue, std::less&lt;int&gt;, MyMapAllocator&gt; myValueMap;</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="stringliteral"> </span></div>
<div class="ttc" id="classalb_1_1affix__allocator_html_a0d8ff4972c9f852b412d0c6746e33b0c"><div class="ttname"><a href="classalb_1_1affix__allocator.html#a0d8ff4972c9f852b412d0c6746e33b0c">alb::affix_allocator::allocate</a></div><div class="ttdeci">block allocate(size_t n)</div><div class="ttdef"><b>Definition:</b> <a href="affix__allocator_8hpp_source.html#l00140">affix_allocator.hpp:140</a></div></div>
<div class="ttc" id="classalb_1_1shared__freelist_html"><div class="ttname"><a href="classalb_1_1shared__freelist.html">alb::shared_freelist</a></div><div class="ttdef"><b>Definition:</b> <a href="freelist_8hpp_source.html#l00241">freelist.hpp:241</a></div></div>
<div class="ttc" id="structalb_1_1block_html"><div class="ttname"><a href="structalb_1_1block.html">alb::block</a></div><div class="ttdef"><b>Definition:</b> <a href="allocator__base_8hpp_source.html#l00023">allocator_base.hpp:23</a></div></div>
<div class="ttc" id="classalb_1_1global__allocator_html"><div class="ttname"><a href="classalb_1_1global__allocator.html">alb::global_allocator</a></div><div class="ttdef"><b>Definition:</b> <a href="global__allocator_8hpp_source.html#l00017">global_allocator.hpp:17</a></div></div>
<div class="ttc" id="classalb_1_1affix__allocator_html"><div class="ttname"><a href="classalb_1_1affix__allocator.html">alb::affix_allocator</a></div><div class="ttdef"><b>Definition:</b> <a href="affix__allocator_8hpp_source.html#l00055">affix_allocator.hpp:55</a></div></div>
<div class="ttc" id="classalb_1_1segregator_html"><div class="ttname"><a href="classalb_1_1segregator.html">alb::segregator</a></div><div class="ttdef"><b>Definition:</b> <a href="segregator_8hpp_source.html#l00028">segregator.hpp:28</a></div></div>
<div class="ttc" id="structalb_1_1block_html_aba144d1fa4c47c4cf5987205a6e430f0"><div class="ttname"><a href="structalb_1_1block.html#aba144d1fa4c47c4cf5987205a6e430f0">alb::block::ptr</a></div><div class="ttdeci">void * ptr</div><div class="ttdoc">This points to the start address of the described memory block. </div><div class="ttdef"><b>Definition:</b> <a href="allocator__base_8hpp_source.html#l00083">allocator_base.hpp:83</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>TUTORIAL.md</b></li>
    <li class="footer">Generated on Sat Oct 10 2015 14:19:58 for Allocator Builder by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
